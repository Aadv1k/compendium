= 50 Algorithms every Programmer must know (Packt Publishing)
Aadvik <aadv1k@outlook.com>

:stem: latexmath

An algorithm is a set of finite, unambiguous deterministic instructions, that with the correct starting conditions can produce a desired output

Correctness: defines how close the algorithm's final *certificate* (a state of execution that gets the algorithm closer to completion) gets to the expected output

Performance
* Iteration is a fundamental of algorithm performance, which can be categorized into three types
** Diverging Iteration: the "bad" case scenario, in this case each iteration doesn't or actively deters the algorithm from completion. This occurs due to bad end-conditions or runaway recursions.
** Converging Iteration: the "good" case where each iteration geets the algorithm closer to the desired output (eg the Fibonacci algorithm)
** Flat Iteration: the neutral case, where the iteration doesn't do anything except completion:

_an example of a converging iteration_

[source, python]
+++
a, b, c = 1, 1, 0

print(0, a, b, sep="\n")

for i in range((n := 10)):
    print((c := a + b))
    a = b
    b = c
+++

* Polynomials and Non-Deterministic Polynomials
** *Polynomial Algorithm* is an algorithm that runs in polynomial time, which is latexmath:[O(N^k)] time. These kinds execute in a "reasonable" time, unlike exponetial algorithms. 
** *Non-Deterministic Polynomials* algorithms for which a "check" which can run in polynomial time exists, to validate their correctness.
** *P = NP cojecture* it can be proven that latexmath:[P \subseteq NP] however, can we say for every algorithm which can be validated in P time there exists a solution also in P time? this is unproven.
** *NP-Hard and NP-Complete* NP-Hard problems are those for which neither a check, nor a solution exists (at-least in polynomial time), *NP-Complete* are problems, for which if a proof can be found out, it can be proven latexmath:[P = NP]

== Algorithmic Strategies

* *Divide and Conquer* break a problem `P` down into `k` chunks, and provide `k` piece of dataset to each chunk to compute.
* *Greedy* approach in which only the first possible solution is found, even if it might not be the most optimial. _if problem is to find a train, departing on time X, then greedy approach will return the first train departing on T < X_
